<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Cube with Miller Indices Plane</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
      #cubeContainer {
        width: 100%;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <div class="container mt-4">
      <h3 class="text-center">3D Cube with Miller Indices Plane</h3>
      <div class="row">
        <div class="col-md-3">
          <form id="millerForm">
            <div class="mb-3">
              <label for="h" class="form-label">Miller Index h:</label>
              <input type="number" class="form-control" id="h" required />
            </div>
            <div class="mb-3">
              <label for="k" class="form-label">Miller Index k:</label>
              <input type="number" class="form-control" id="k" required />
            </div>
            <div class="mb-3">
              <label for="l" class="form-label">Miller Index l:</label>
              <input type="number" class="form-control" id="l" required />
            </div>
            <button type="submit" class="btn btn-primary">Show Plane</button>
          </form>
        </div>
        <div class="col-md-9" id="cubeContainer"></div>
      </div>
    </div>

    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.module.js/+esm';
      import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.167.1/examples/jsm/controls/OrbitControls.js/+esm';

      let scene, camera, renderer, cube, plane, axesHelper;

      // Initialize the scene, cube, and axes
      function init() {
        const container = document.getElementById('cubeContainer');

        // Create the scene and camera
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          container.offsetWidth / container.offsetHeight,
          0.1,
          1000
        );
        camera.position.z = 5;

        // Create the renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.offsetWidth, container.offsetHeight);
        container.appendChild(renderer.domElement);

        // Create a wireframe cube with white edges, offset by (-0.5, -0.5, -0.5)
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const edges = new THREE.EdgesGeometry(geometry);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff }); // White edges
        cube = new THREE.LineSegments(edges, lineMaterial);
        cube.position.set(0.5, 0.5, 0.5); // Shift cube to place bottom-back corner at (0, 0, 0)
        scene.add(cube);

        // Create axes from the bottom-back corner of the cube and extend by 50%
        axesHelper = new THREE.AxesHelper(2.25); // Increased from 1.5 to 2.25
        scene.add(axesHelper);

        // Add controls to rotate the cube
        const controls = new OrbitControls(camera, renderer.domElement);

        animate();
      }

      // Animate the scene
      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }

      // Function to create a plane based on Miller indices
      function createPlane(h, k, l) {
        // Remove previous plane if it exists
        if (plane) {
          scene.remove(plane);
        }

        // Set the plane constant D = 1
        const D = 1 / (h ** 2 + k ** 2 + l ** 2);

        // Define the normal vector of the plane based on Miller indices
        const normal = new THREE.Vector3(h, k, l);

        // Create a finite plane geometry for rendering without extra x-lines
        const planeGeometry = new THREE.PlaneGeometry(3, 3); // Size the plane large enough for visualization
        const planeMaterial = new THREE.MeshBasicMaterial({
          color: 0xffa500, // Orange
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.5,
        });

        plane = new THREE.Mesh(planeGeometry, planeMaterial);

        // Position the plane at (0,0,0) and orient it based on the normal
        plane.position.copy(normal.multiplyScalar(D));
        plane.lookAt(normal.add(plane.position));

        scene.add(plane);
      }

      // Handle form submission to show the plane
      document
        .getElementById('millerForm')
        .addEventListener('submit', function (event) {
          event.preventDefault();

          const h = parseFloat(document.getElementById('h').value);
          const k = parseFloat(document.getElementById('k').value);
          const l = parseFloat(document.getElementById('l').value);

          createPlane(h, k, l);
        });

      // Handle resizing of the canvas
      window.addEventListener('resize', () => {
        const container = document.getElementById('cubeContainer');
        camera.aspect = container.offsetWidth / container.offsetHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.offsetWidth, container.offsetHeight);
      });

      // Initialize the scene on load
      init();
    </script>
  </body>
</html>
